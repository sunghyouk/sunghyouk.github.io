---
layout  : wiki
title   : "R을 이용한 데이터 처리 & 분석 실무 Chapter 3"
summary : "Chapter 3. R 프로그래밍"
date    : 2022-01-10 17:02:07 +0900
updated : 2022-01-15 22:10:59 +0900
tag     : 
toc     : true
public  : true
parent  : [[2022-01-10-practical_R]]
latex   : false
---

## 01. R의 특징

* 벡터 연산을 더 자주 사용  
* 결측치: 관측 또는 기록되지 않은 데이터를 표시하기 위한 NA가 있음  
* 객체의 불변성: 대부분의 R 객체는 그 값을 수정할 수 없음

## 02. 흐름 제어 (조건문과 반복문)

### if

```R
if (cond) {
    cond가 참일 때 실행할 문장
} else {
    cond가 거짓일 때 실행할 문장
}
```

다수의 TRUE, FALSE 값의 처리에 ifelse()를 고려할 수 있다.

```R
ifelse(
    test, # 참, 거짓을 저장한 객체
    yes, # test가 참일 때 선택한 값
    no # test가 거짓일 때 선택한 값
)
```

### 반복문

```R
#for
for (i in data) {
    i를 사용한 문장
}

#while
while (cond) {
    조건이 참일 때 수행할 문장
}

#repeat
repeat {
    반복해서 수행할 문장
}
```

`break`: 반복문을 종료  
`next`: 현재 수행 중인 반복문 블록의 수행을 중단, 다음 반복을 시작

## 03. 연산

### 수치 연산

각 숫자를 개별적으로 연산하는 것이 아니라 벡터에 통째로 연산자를 적용하고 있음  
벡터, 행렬의 연산  

### 벡터 연산

벡터 연산 또는 array programming은 벡터 또는 리스트를 한 번에 연산하는 것을 말한다.  
벡터 간 연사 시 `&`를 사용함.  
기본적으로 벡터 기반 연산을 지원 - 벡터를 곧바로 인자로 받을 수 있다.  
*example)* function: sum(), mean(), median(), ifelse()도 그렇다.  

데이터 프레임에 진리값을 지정해 특정 행을 얻어올 수 있다.  
*example* code  

```R
d <- data.frame(x=c(1, 2, 3, 4, 5), y=c("a", "b", "c", "d", "e")) # data frame 만들기

d[d$x %% 2 == 0, ] # x가 짝수인 경우의 행만 선택
```

### NA의 처리

`na.rm`: NA 값이 있을 때 해당 값을 연산에서 제외할 것인지를 지정하는 데 사용  
NA를 어떻게 처리할 지를 `na.action`이라는 함수 인자로 받았다면, 데이터 프레임에 `na.action`을 실행해 현재 처리 중인 데이터를 사용자가 원하는 대로 정제할 수 있다.  
*example* na.fail(), na.omit(), na.exclude(), na.pass()  

## 04. 함수의 정의

### 기본 정의

```R
function_name <- function(arg1, arg2, ...) {
    함수 본문
    return(반환 값) # 반환 값이 없다면 생략
}
```

### 가변 길이 인자

`...`은 개수를 알 수 없는 임의의 인자를 표현하는 데 사용, 내부에서 호출하는 다른 함수에 넘겨줄 인자를 표시하는 데도 사용한다.  

### 중첩 함수

함수 안에 또 다른 함수를 정의하여 사용  
함수 안에서 반복되는 동작을 한 함수로 만들고 이를 호출하여 코드를 간결하게 표현  
내부 함수가 외부 함수에 정의된 변수를 접근할 수 있어 closure로 사용할 수 있다.  

## 05. 스코프

코드에 기술한 이름 (예를 들면, 변수명)이 어디에서 사용 가능한지를 정하는 규칙  
문법적 스코프 (정적 스코프)를 사용  
콘솔에서 변수를 선언하면 모든 곳에서 사용가능한 전역 변수가 된다.  
source()를 사용해 실행할 경우 다른 파일에서도 해당 변수를 사용할 수 있다.  
함수 내부의 지역 변수가 우선한다.  

`rm`: 지정한 환경에서 객체를 삭제  
`ls`: 객체를 나열한다.  

```R
rm(
    ..., # 삭제할 객체의 목록
    list=character(), # 삭제할 객체를 나열한 벡터
    envir=as.environment(pos) # 객체를 삭제할 환경
)

ls(
    name, # 객체를 나열할 환경의 이름
    envir # name 대신 직접 환경을 지정할 경우 사용
)

# therefore
rm(list=ls()) # 메모리에 있는 모든 객체를 삭제하라!
```

함수 내부에 정의한 이름은 함수 바깥에서 접근할 수 없다.  
함수 내에서 이름은 함수 안의 변수들로부터 먼저 찾는다. 중첩 함수에도 같은 규칙이 적용된다.  

내부 블록에서 외부 블록에 선언된 값을 수정하고자 할 때, 값이 할당되는 대상이 내부 블록으로 간주되기 때문에 조심해야 한다.  
만약 중첩 함수에서 외부 함수의 변수 또는 전역 변수에 값을 할당하려면 `<<-`을 사용해야 한다.  

## 06. 값에 의한 전달 (Pass by value)

객체가 복사되어 함수로 전달된다는 의미.  
데이터 프레임을 함수에 인자로 주었을 때 함수 내부에서 수행한 변경은 원래 객체에 반영되지 않는다.  
함수를 호출한 쪽에 반영하려면 함수를 호출한 쪽에서 원래 변수에 할당해야 한다.  

## 07. 객체의 불변성

R의 객체는 (거의 대부분의 경우에) 불변이다.  

*Conference)* 실제로 일어나는 일은 a를 복사한 새로운 객체 a'을 만들고 이 a'에 필드 b를 추가하고 해당 필드에 c(1, 2, 3)을 채워넣은 다음, 변수명 a가 a'을 가리키도록 하는 것이다. 이전 객체는 버려지며 새로이 a'=c(1, 2, 3)을 담고 있는 새로운 객체가 만들어지고, a는 이 새로운 객체의 이름이 된다.  

`tracemem()`: 객체의 복사를 추적한다.  
`untracemem()`: 객체 복사 추적을 중단한다.  

벡터 기반 연산이 더 효율적인 이유가 여기서 나온다.  
for 문 안에서 벡터의 인자를 하나씩 바꾸는 코드를 실행하면 새로운 객체를 하나씩 계속 만들어 나간다.  
하지만, 벡터 기반 연산에서는 전체 값을 1만큼 증가시킨 객체를 한 개를 만들어 이를 새로 할당. - 새 객체를 만들 필요가 없다.  
이러한 메모리 사용 최적화 문제와 관련이 있다.

## 08. 모듈 패턴

모듈이란 외부에서 접근할 수 없는 데이터와 그 데이터를 제어하기 위한 함수로 구성된 구조물을 말한다.  
모듈 패턴의 장점:  
1) 내부 구현이 숨겨진다.
2) 사전에 정의된 함수로만 데이터를 다룰 수 있게 설계됨
3) 모듈의 제작자는 해당 함수가 같은 결과를 내놓게만 설계가 되면 내부 구조나 데이터 구조를 바꿀 수 있음

### 큐 (Queue)

큐를 모듈로 작성해 보기, FIFO, first in first out  

```R
queue <- function() {
    q <- c() # 지역 변수가 됨
    q_size <- 0 # 지뎍 변수가 됨
    
    enqueue <- function(data) {
        q <<- c(q, data)
        q_size <<- q_size +1
    }
    
    dequeue <- function() {
        first <- q[1]
        q <<- q[-1]
        q_size <<- q_size -1
        return(first)
    }
    
    size <- function() {
        return(q_size)
    }
    
    return(list(enqueue=enqueue, dequeue=dequeue, size=size))
}

```

### 큐 모듈 작성하기

데이터의 무결성이 전역 변수를 조작하게 함으로서 깨질 수 있다. 그러므로 큐 코드 전체와 관련된 변수를 한 함수 안으로 감추는 것으로 해결.
이제 지역 변수가 되서 외부에서 접근이 불가능  
최종 함수 값들은 따로따로 반환되는 것이 아니라 queue라는 함수의 리스트로 반환된다.  
게다가 queue() 함수를 호출할 때마다 매번 새로 생성되서 서로 섞이지 않는다.  
이는 R에만 있는 것이 아니라, JavaScript에도 같은 이름으로 같은 개념이 사용된다.  

